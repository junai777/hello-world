模拟面试地址https://bitable.feishu.cn/appwBhd98QJ9cpMggHc5QMVHlfd?from=navigation_button_1_trial&table=tbleuLHpPcQdvL4F&view=vew9iquA45


进程线程概念
进程线程通信
IO模型
微服务
注册中心
服务降级原理
分布式事务实现原理       https://www.cnblogs.com/bluemiaomiao/p/11216380.html
redismysql消息队列一致性   https://zhuanlan.zhihu.com/p/91770135
java map resize       https://zhuanlan.zhihu.com/p/55890890
乐观锁与悲观锁实现原理   https://www.cnblogs.com/X-knight/p/10669934.html#_label2
lock与AQS
可重入锁原理
atomic类
怎么设计线程池     https://juejin.cn/post/6844903494223151112#heading-7
volatile synchronized实现原理
读写屏障
类加载机制
双亲委派
JMM内存模型
GC(CMS,G1,ZGC)
jdk8新特性stream及性能问题
ioc,aop,bean生命周期

分库分表  https://juejin.cn/post/6844903929457672205

mysql存储引擎及特性(myisam,innodb,memory,federate)
b-b+树
索引
锁与并发
ACID
隔离级别及原理
MVCC与间隙锁
RR解决幻读
提高性能(范式与反范式,sql优化,索引等)
覆盖索引
回表查询
最左匹配原则

redis数据结构
string存储原理
zset跳表原理及复杂度
哨兵机制
主从复制(全量增量)
持久化机制
aof的rewrite机制(怎么保持一致性)
渐进式哈希
缓存击穿雪崩穿透
分布式锁
setnx与expire合并成原子操作

MQ拓扑
不同MQ举例和差异
MQ集群逻辑

CICD的理解
Jenkins

怎么对推送的视频进行去重(user_id, video_id)
数据量很大了怎么办(布隆过滤器)
怎么保证扩容的并发性能且保证原子性
rpc与消息队列的区别
设计一个统计用户聊天人数与聊天数的系统(set)
设计一个抢红包系统(rpush&lpop)
http与redis通信方式(RESP)差异
为什么redis不用http
http数据包的格式
mysql与redis的高可用与数据分表
redis数据槽之间数据怎么迁移
类似朋友圈系统的设计
有大V网红怎么处理(热点数据池)


反射
注解
抽象工厂模式
迭代器模式
适配器模式
CAS
epoll
IO多路复用



xss
csrf

如何设计分布式缓存
如何设计高并发系统
如何设计消息队列
如何设计秒杀系统

进程间通信：无名管道、有名管道、信号、消息队列     https://www.jianshu.com/p/c1015f5ffa74      https://juejin.cn/post/6896383206350831630#heading-23
socket各个函数含义
es refresh  flush  translog https://www.jianshu.com/p/15837be98ffd
es query 原理  任务队列
协程

程序的运行

用户态和内核态 https://juejin.cn/post/6860166482710495246

线程间的通信方式: 互斥量,信号量,事件
协程的概念
分段和分页以及对应的场景
ping与TTL
工厂模式和观察者模式
中断的分类
软中断和硬中断
红黑树最重要的性质：从根到叶子的最长的可能路径小于等于最短的可能路径的两倍长。
创建对象的方式
多态 编译时多态 运行时多态
单例模式(线程安全)

写一个死锁的例子

volatile
synchronized
ReetrantLock实现方式




Java 线程池有哪些参数
线程池的工作过程
roaring bitmap
java基础https://juejin.cn/post/6932040503047225351#heading-22


mysql char vchar
rabbitmq如何保证至少一次  如果想要保证至少一次投递，使用队列镜像，持久的队列，持久的消息，发布者ACK，mandatory标志位，手动消费者ACK；
mq消息丢失
生产者丢消息：使用confirm模式，使用ack来确认是否成功投递
消息队列丢数据：使用镜像集群+持久化落盘，待写到主片和全部副片时才返回ack
消费者丢数据：消费者返回ack才处理成功，否则不断重发


可重复读和幻读
分布式id生成雪花算法的时间漂移  依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成id冲突或者重复。
redis数据淘汰策略实现
分库分表策略
http头进行数据标识
TCP粘包
CDN 内容分发网络，可缓存静态Web内容和流媒体内容，实现内容的边缘传播和存储，以便用户的就近访问。


三色标记
CMS：写屏障+增量更新，即有黑色指向白色时记录下这个引用
G1:写屏障+SATB，即灰色断开指向白色的时候，记录下这个引用

意向锁
为了避免申请表锁时去遍历整个表检测行锁。
即对某个行做修改会先获得意向共享锁
申请表锁时会先获得意向排他锁
如果有事务对某个行做修改，会有意向共享锁
这时申请表锁就被阻塞

next key lock
mvcc在RR RC下的不同
RR的读视图在事务开始时建立
RC的读视图在每条语句开始时建立

mysql各种日志
双写  
InnoDB 的Page Size一般是16KB，写文件是以4KB作为单位的，在极端情况下（比如断电）往往并不能保证这一操作的原子性16K的数据，
写入4K 时，发生了系统断电/os crash ，只有一部分写是成功的，这种情况下就是 partial page write 问题。
有人会想到系统恢复后MySQL可以根据redolog 进行恢复，而mysql在恢复的过程中是检查page的checksum，checksum就是pgae的最后事务号，发生partial page write 问题时，p
age已经损坏，找不到该page中的事务号，就无法恢复。
为了解决 partial page write 问题
1.当mysql将脏数据flush到data file的时候, 先使用memcopy 将脏数据复制到内存中的double write buffer ，
2.通过double write buffer再分2次，每次写入1MB到共享表空间，
3.然后马上调用fsync函数，同步到磁盘上，避免缓冲带来的问题。

缓存机制及所用数据结构
https://www.cnblogs.com/jiangxu67/p/3765708.html

redo log 为什么不直接落盘
组提交节省IO

fork的子进程拥有父进程的文件描述符吗？
子进程会继承父进程的文件描述符，父子进程对同一个文件进行写，将共享文件偏移，所以如果父子进程的其中一个使用了fclose关闭了文件描述符，实际上还有另外一个进程打开了test.txt文件。
如果父子进程都对文件进行写，并不会产生两个不同的文件，而是会对同一个文件进行写，因此运行后会在同一个文件里出现父子进程写的内容

fork
子进程拥有父进程的数据段，代码段，堆栈的副本
其实使用了写时复制技术，即fork之后，子进程名义上拥有父进程的副本，但是实际上和父进程共用，只有当父子进程中有一个试图修改这些区域时，才会以页为单位创建一个真正的副本。


mvcc
多版本并发控制,目的在于提高数据库高并发场景下的吞吐性能. 
不同的事务在并发过程中，SELECT 操作可以不加锁而是通过 MVCC 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。
快照读使用版本号加活跃数组构成的视图来实现，当前读对相应的行和间隙加锁。确保了读读不阻塞，读写不阻塞，只是写写阻塞。

线程池队列
(有界队列)ArrayBlockingQueue,
(无界队列)LinkedBlockingQeque,
(优先级队列)PriorityBlockingQueue，

线程池参数设置
IO密集型 2*CPU核数
计算密集型 CPU核数+1



AQS原理
AbstractQueuedSynchronizer 抽象的队列式同步器
AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。
用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。
AQS 定义了两种资源共享方式：
1.Exclusive：独占，只有一个线程能执行，如ReentrantLock
2.Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier
state   使用了volatile修饰
https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html

段式
按照程序自身的逻辑关系划分为若干个段，内存分配规则：以段为单位进行分配，每个段在内存中占连续空间，但各段之间可以不相邻
分段对用户是可见的
优点：很方便按照逻辑模块实现信息的共享和保护
缺点：段长过大，很难为其分配连续的内存空间

页式
分页对用户不可见
优点：内存空间利用率高，不会产生外部碎片，只有少量内部碎片
缺点：不方便按照逻辑模块实现信息的共享和保护

段页式
既可以方便按照逻辑模块实现信息的共享和保护，又可以实现高的内存利用率





